/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-npm-audit-fix",
factory: function (require) {
var plugin=(()=>{var D=Object.create;var f=Object.defineProperty;var S=Object.getOwnPropertyDescriptor;var k=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,E=Object.prototype.hasOwnProperty;var h=(o=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(o,{get:(t,s)=>(typeof require<"u"?require:t)[s]}):o)(function(o){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+o+'" is not supported')});var N=(o,t)=>{for(var s in t)f(o,s,{get:t[s],enumerable:!0})},A=(o,t,s,a)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of k(t))!E.call(o,i)&&i!==s&&f(o,i,{get:()=>t[i],enumerable:!(a=S(t,i))||a.enumerable});return o};var P=(o,t,s)=>(s=o!=null?D(x(o)):{},A(t||!o||!o.__esModule?f(s,"default",{value:o,enumerable:!0}):s,o)),b=o=>A(f({},"__esModule",{value:!0}),o);var $={};N($,{default:()=>I});var R=h("stream"),g=h("@yarnpkg/cli"),e=h("@yarnpkg/core"),c=P(h("typanion")),U=c.isObject({advisories:c.isDict(c.isObject({module_name:c.isString(),vulnerable_versions:c.isString(),patched_versions:c.isString()},{extra:c.isDict(c.isUnknown())}))},{extra:c.isDict(c.isUnknown())}),v=class extends g.BaseCommand{async execute(){let t=await this.initState(),{configuration:s,project:a,cache:i}=t;return(await e.StreamReport.start({configuration:s,stdout:this.context.stdout},async n=>{let m=await n.startTimerPromise("Audit step",()=>this.getAdvisories());for(let p of m){let l=e.structUtils.prettyIdent(s,e.structUtils.parseIdent(p.module_name)),r=e.structUtils.prettyRange(s,p.vulnerable_versions),u=e.structUtils.prettyRange(s,p.patched_versions);await n.startTimerPromise(`Advisory for ${l} at ${r}, patched at ${u}`,()=>this.handleAdvisory(n,t,p))}await a.install({report:n,cache:i,mode:e.InstallMode.UpdateLockfile})})).exitCode()}async handleAdvisory(t,s,a){let{configuration:i,resolver:d,project:n}=s,m=e.structUtils.parseIdent(a.module_name),p=new Set,l=new Set;for(let r of n.storedDescriptors.values()){if(!e.structUtils.areIdentsEqual(r,m)||e.structUtils.isVirtualDescriptor(r))continue;let u=n.storedPackages.get(n.storedResolutions.get(r.descriptorHash));if(!u||!e.semverUtils.satisfiesWithPrereleases(u.version,a.vulnerable_versions))continue;t.reportInfo(e.MessageName.UNNAMED,`Found vulnerable ${e.structUtils.prettyLocator(i,u)} (via ${e.structUtils.prettyRange(i,r.range)})`);let w=(await d.getCandidates(r,new Map,{project:n,report:t,resolver:d}))[0];if(!w){t.reportError(e.MessageName.UNNAMED,`No candidates found for ${e.structUtils.prettyDescriptor(i,r)}`);continue}let y=await d.resolve(w,{project:n,report:t,resolver:d});if(!e.semverUtils.satisfiesWithPrereleases(y.version,a.patched_versions)){t.reportWarning(e.MessageName.UNNAMED,`No compatible patched version found for ${e.structUtils.prettyDescriptor(i,r)}`);continue}t.reportInfo(e.MessageName.UNNAMED,`Attempting to upgrade ${e.structUtils.prettyDescriptor(i,r)} to ${e.structUtils.prettyLocator(i,y)}`),p.add(r.descriptorHash),l.add(u.locatorHash)}p.forEach(r=>void n.storedResolutions.delete(r)),l.forEach(r=>void n.storedPackages.delete(r))}async initState(){let t=await e.Configuration.find(this.context.cwd,this.context.plugins),{project:s,workspace:a}=await e.Project.find(t,this.context.cwd),i=await e.Cache.find(t);if(!a)throw new g.WorkspaceRequiredError(s.cwd,this.context.cwd);await s.restoreInstallState();let d=t.makeResolver();return{configuration:t,workspace:a,cache:i,project:s,resolver:d}}async getAdvisories(){let t=new R.PassThrough,s=[];t.on("data",d=>{s.push(d)}),await this.cli.run(["npm","audit","-AR","--json"],{stdout:t}),t.end();let a=JSON.parse(Buffer.concat(s).toString());if(!U(a))throw new Error("Unexpected yarn npm audit result");let i=[];return Object.entries(a.advisories).forEach(([d,n])=>{i.push(n)}),i}};v.paths=[["npm","audit","fix"]];var _={commands:[v]},I=_;return b($);})();
return plugin;
}
};
